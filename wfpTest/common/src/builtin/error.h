// Copyright (c) 2020 Private Internet Access, Inc.
//
// This file is part of the Private Internet Access Desktop Client.
//
// The Private Internet Access Desktop Client is free software: you can
// redistribute it and/or modify it under the terms of the GNU General Public
// License as published by the Free Software Foundation, either version 3 of
// the License, or (at your option) any later version.
//
// The Private Internet Access Desktop Client is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with the Private Internet Access Desktop Client.  If not, see
// <https://www.gnu.org/licenses/>.

#include "common.h"
#line HEADER_FILE("builtin/error.h")

#ifndef BUILTIN_ERROR_H
#define BUILTIN_ERROR_H
#pragma once

#include <exception>

#define LOG_FILE __FILE__
#define LOG_LINE __LINE__
#define LOG_FUNC nullptr

struct COMMON_EXPORT CodeLocation
{
	const char* file;
	int line;

	CodeLocation() : file(nullptr), line(0) {}
	CodeLocation(const char* file, int line)
		: file(file), line(line) {}

	const char* categoryName() const { return ""; }

	template<class Error, typename... Args>
	inline Error createError(Args&... args)
	{
		return Error(std::move(*this), std::forward<Args>(args)...);
	}
};

#define THIS_LOCATION CodeLocation(LOG_FILE, LOG_LINE)
#define HERE THIS_LOCATION
/**
 * @brief The Error class is the base class for all errors that may need
 * to be reported to the user.
 */
class COMMON_EXPORT Error : public std::exception
{
public:
    enum Code : int
    {
        Success = 0,                      // No error

        Unknown = 1,                      // %1 = description (optional)
        System = 2,                       // %1 = system error code, %2 = description, %3 = operation (optional),
        Check = System,

        InvalidEnumValue,

        JsonFieldError,                   // %1 = field name, %2 = field type (empty for nonexistent fields), %3 = value (optional)
        JsonCastError,

        // Standard JSON RPC codes
        JsonRPCParseError = -32700,
        JsonRPCInvalidRequest = -32600,
        JsonRPCMethodNotFound = -32601,
        JsonRPCInvalidParams = -32602,
        JsonRPCInternalError = -32603,

        // User-defined JSON RPC codes (-32000 - -32099)
        JsonRPCConnectionLost = -32000,

        // CLI-specific exit codes
        CliInvalidArgs = -100,
        CliTimeout = -101,

        // Errors generated by IPC
        IPCNotConnected = 100,

        DaemonConnectionError = 500,

        OpenVPNError = 1000,
        OpenVPNProcessFailedToStart,
        OpenVPNProcessCrashed,
        OpenVPNManagementAcceptError,
        OpenVPNManagementListenError,
        OpenVPNManagementWriteError,
        OpenVPNTLSHandshakeError,
        OpenVPNConfigFileWriteError,
        OpenVPNAuthenticationError,
        OpenVPNDNSConfigError,
        OpenVPNProxyResolveError,
        OpenVPNProxyAuthenticationError,
        OpenVPNProxyError,

        FirewallError = 1100,
        FirewallInitializationError,
        FirewallRuleFailed,

        ApiNetworkError = 1200,
        ApiRateLimitedError,
        ApiBadResponseError,
        ApiUnauthorizedError,
        ApiInterfaceError,  // Need to use a specific interface for the API request, but the interface isn't ready

        VersionUnparseableError = 1300,

        TaskRejected = 1400,
        TaskStillPending,
        TaskDestroyedWhilePending,
        TaskRecipientDestroyed,
        TaskTimedOut,

        // Errors returned by Daemon RPC calls
        DaemonRPCDiagnosticsFailed = 1500,
        DaemonRPCDiagnosticsNotEnabled,
        DaemonRPCDaemonInactive,    // RPC rejected because no active client is connected
        DaemonRPCNotLoggedIn,   // RPC rejected because the user has not logged in
        DaemonRPCUnknownSetting,    // RPC rejected due to unknown setting property

        // Network adapter errors (can be thrown by Daemon implementations)
        NetworkAdapterNotFound = 1600,

        // Wireguard connectivity errors
        WireguardAddKeyFailed = 1700,
        WireguardCreateDeviceFailed,
        WireguardConfigDeviceFailed,
        WireguardDeviceLost,
        WireguardHandshakeTimeout,
        WireguardProcessFailed,
        WireguardNotResponding,
        WireguardPingTimeout,

        // Connectivity errors for multiple VPN methods
        VPNConfigInvalid = 1800,

        LocalSocketConnectionFailed = 1900,
    };
 
public:
	Error()
		: _systemCode(0) {}

	Error(Code code, const char* params)
		: _code(code) {}


#if defined(Q_OS_WIN)
    typedef unsigned long SystemCode;
#else
    typedef int SystemCode;
#endif

protected:
	Code _code;
	SystemCode _systemCode;
};


// Throw a check failure exception with a string describing the operation.
// The string is ignored in release builds. The second optional argument
// is a system error code; if omitted, CHECK_THROW will get the code from
// the operating system.
#define CHECK_THROW(operation, ...)  throw CheckError(HERE,##__VA_ARGS__,_D(operation)_R(nullptr))

// Check if a value (typically a return value) matches a certain predicate,
// and throws an exception if it does. Useful for making flat RAII-based
// call chains instead of nested if statements and cleanups.
#define CHECK_IF(predicate,expr)     ([](auto&& value){ auto error = SYSTEM_LAST_ERROR; if (predicate)         CHECK_THROW(#expr, error); return std::forward<decltype(value)>(value); }(expr))
// Same as CHECK_IF except throws an exception if the value does NOT match
// the given predicate.
#define CHECK_IF_NOT(predicate,expr) ([](auto&& value){ auto error = SYSTEM_LAST_ERROR; if (predicate) {} else CHECK_THROW(#expr, error); return std::forward<decltype(value)>(value); }(expr))

// Check the result of a function that directly returns an error code.
#define CHECK_ERROR_IF(predicate,expr) (([](auto&& error){ if (error && (predicate)) CHECK_THROW(#expr, error); return std::forward<decltype(error)>(error); })(expr))
#define CHECK_ERROR(expr)            CHECK_ERROR_IF(true,expr)

#define CHECK_IF_TRUE(expr)          CHECK_IF(value, expr)
#define CHECK_IF_ZERO(expr)          CHECK_IF(value == 0, expr)
#define CHECK_IF_POSITIVE(expr)      CHECK_IF(value > 0, expr)
#define CHECK_IF_NEGATIVE(expr)      CHECK_IF(value < 0, expr)
#define CHECK_IF_NULL(expr)          CHECK_IF(value == nullptr, expr)

#define CHECK_IF_FALSE(expr)         CHECK_IF_NOT(value, expr)
#define CHECK_IF_NOT_ZERO(expr)      CHECK_IF_NOT(value == 0, expr)
#define CHECK_IF_NOT_POSITIVE(expr)  CHECK_IF_NOT(value > 0, expr)
#define CHECK_IF_NOT_NEGATIVE(expr)  CHECK_IF_NOT(value < 0, expr)
#define CHECK_IF_NOT_NULL(expr)      CHECK_IF_NOT(value == nullptr, expr)

// Check for the -1 error return value commonly used by POSIX functions.
#define CHECK_IF_MINUS_ONE(expr)     CHECK_IF(value == -1, expr)
// Check for the INVALID_HANDLE_VALUE error return value on Windows.
#define CHECK_IF_INVALID(expr)       CHECK_IF(value == INVALID_HANDLE_VALUE, expr)

#ifdef Q_OS_WIN
#define CHECK_ALLOC(expr)            CHECK_IF((value == nullptr ? (error = ERROR_NOT_ENOUGH_MEMORY), true : false), expr)
#else
#define CHECK_ALLOC(expr)            CHECK_IF((value == nullptr ? (error = ENOMEM), true : false), expr)
#endif


// Global function to report an Error from a location that cannot throw
// an exception (e.g. in a slot that might be invoked directly by Qt).
//
extern void COMMON_EXPORT reportError(Error error);



// Macro to run an expression or statement or block inside a try..catch
// block and report any errors using a report function (should take a
// single parameter of type Error).
//
#define GUARD_WITH(report, ...) \
    do { \
        try \
        { \
            __VA_ARGS__; \
        } \
        catch (const Error& e) \
        { \
            report(e); \
        } \
        catch (...) \
        { \
        } \
    } while(0)

// Macro to run an expression or statement or block inside a try..catch
// block and report any errors using the global reportError function.
//
#define GUARD(...) GUARD_WITH(reportError,##__VA_ARGS__)

// Function to run a function/functor inside a try..catch block and report
// any errors using a report function (should take a single parameter of
// type Error). The return value of the function/functor is ignored, and
// instead this function returns true if the function/functor completed
// without throwing any exceptions, or false otherwise.
//
template<typename Func, typename Report, typename... Args>
static inline bool guardWith(Func&& func, Report&& report, Args&&... args)
{
    GUARD_WITH(report, { func(std::forward<Args>(args)...); return true; });
    return false;
}

// Function to run a member function inside a try...catch block and report
// any errors using a report function (should take a single parameter of
// type Error). The return value of the function/functor is ignored, and
// instead this function returns true if the function/functor completed
// without throwing any exceptions, or false otherwise.
//
template<class Class, typename Ptr, typename Report, typename Return, typename... Args>
static inline bool guardWith(Return (Class::*func)(Args...) const, Ptr&& context, Report&& report, Args&&... args)
{
    GUARD_WITH(report, { ((context)->*(func))(std::forward<Args>(args)...); return true; });
    return false;
}

// Function to run a function/functor inside a try..catch block and report
// any errors using the global reportError function.
//
template<typename Func, typename... Args>
static inline bool guard(Func&& func, Args&&... args)
{
    GUARD({ func(std::forward<Args>(args)...); return true; });
    return false;
}

// Function to run a member function inside a try...catch block and report
// any errors using the global reportError function.
//
template<class Class, typename Ptr, typename Return, typename... Args>
static inline bool guard(Return (Class::*func)(Args...) const, Ptr&& context, Args&&... args)
{
    GUARD({ ((context)->*(func))(std::forward<Args>(args)...); return true; });
    return false;
}

// Hash Error::Code as int
namespace std
{
    template<>
    struct hash<Error::Code> : public hash<int> {};
}

#endif // BUILTIN_ERROR_H
